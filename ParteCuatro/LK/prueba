import cv2
import numpy as np
import os

window = "Lucas-Kanade Optical Flow"
images_folder = "imagenes1"
output_file_path = "promedio_por_celda_por_frameLK.txt"
final_output_file_path = "promedio_final_por_celdaLK.txt"

# Obtener la lista de nombres de archivos de imágenes en la carpeta
image_files = sorted(os.listdir(images_folder))

# Obtener el tamaño de las imágenes de entrada
first_image = cv2.imread(os.path.join(images_folder, image_files[0]))
height, width, _ = first_image.shape

# Calcular el tamaño de cada cuadro en la matriz 20x20
cell_width = width // 20
cell_height = height // 20

# Inicializar algunas variables
old_gray = None
p0 = None
iteration_count = 0  # Contador de iteraciones
cell_magnitude_sum = np.zeros((20, 20))  # Matriz para almacenar la suma de magnitudes por celda
cell_count = np.zeros((20, 20), dtype=int)  # Matriz para almacenar el conteo de vectores por celda
cell_averages_per_frame = []  # Lista para almacenar los promedios por celda por cada par de frames

# Función para calcular la magnitud de un vector
def calculate_magnitude(vector):
    return np.sqrt(vector[0] ** 2 + vector[1] ** 2)

# Función para calcular la celda correspondiente a una coordenada
def calculate_cell(x, y):
    return min(int(x // cell_width), 19), min(int(y // cell_height), 19)

# Función para dibujar la cuadrícula en la imagen
def draw_grid(frame):
    for i in range(0, width, cell_width):
        cv2.line(frame, (i, 0), (i, height), (0, 255, 255), 1)
    for j in range(0, height, cell_height):
        cv2.line(frame, (0, j), (width, j), (0, 255, 255), 1)

# Iterar sobre pares de imágenes consecutivas
for i in range(len(image_files) - 1):
    # Cargar las dos imágenes consecutivas
    image_path1 = os.path.join(images_folder, image_files[i])
    image_path2 = os.path.join(images_folder, image_files[i + 1])
    frame1 = cv2.imread(image_path1)
    frame2 = cv2.imread(image_path2)

    # Convertir a escala de grises
    gray1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)

    # Si es el primer cuadro o después de cierto tiempo, detectar esquinas nuevamente
    if old_gray is None or iteration_count % 50 == 0:
        p0 = cv2.goodFeaturesToTrack(gray1, mask=None, maxCorners=200, qualityLevel=0.0008, minDistance=10, blockSize=5, k=0.004)
        old_gray = gray1.copy()

    else:
        # Calcular el flujo óptico con el algoritmo de Lucas-Kanade
        p1, st, err = cv2.calcOpticalFlowPyrLK(old_gray, gray2, p0, None, winSize=(50, 50), maxLevel=4,
                                                criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.001))

        # Verificar que el cálculo del flujo óptico fue exitoso
        if p1 is not None:
            # Seleccionar puntos buenos
            good_new = p1[st == 1]
            good_old = p0[st == 1]

            # Calcular vectores y actualizar sumas y conteos de celdas
            for new, old in zip(good_new, good_old):
                vector = (new[0] - old[0], new[1] - old[1])
                magnitude = calculate_magnitude(vector)
                if magnitude > 0.5:
                    cell_x, cell_y = calculate_cell(old[0], old[1])
                    cell_magnitude_sum[cell_y, cell_x] += magnitude
                    cell_count[cell_y, cell_x] += 1

            # Actualizar los puntos anteriores
            p0 = good_new.reshape(-1, 1, 2)
            old_gray = gray2.copy()

    # Dibujar la cuadrícula en cada celda
    draw_grid(frame1)

    # Mostrar la imagen con la cuadrícula
    cv2.imshow(window, frame1)

    # Imprimir el número de iteración
    print("Iteración:", iteration_count)

    # Esperar el tiempo necesario para mantener la velocidad del video original
    key = cv2.waitKey(100) & 0xFF

    # Si la tecla es ESC, salir
    if key == 27:
        break

    # Incrementar el contador de iteraciones
    iteration_count += 1

    # Calcular el promedio por celda de la magnitud de los vectores
    average_magnitude_per_cell = cell_magnitude_sum / np.maximum(cell_count, 1)

    # Añadir los promedios por celda a la lista
    cell_averages_per_frame.append(average_magnitude_per_cell)

# Calcular el promedio final de los promedios por celdas
final_average_per_cell = np.mean(cell_averages_per_frame, axis=0)

# Guardar el promedio final de los promedios por celdas en el archivo final
with open(final_output_file_path, 'w') as final_file:
    final_file.write("Promedio final por celda:\n")
    for y in range(20):
        for x in range(20):
            final_file.write("Promedio final de celda ({}, {}): {}\n".format(x, y, final_average_per_cell[y, x]))

cv2.destroyAllWindows()
